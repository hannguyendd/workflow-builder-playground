from dataclasses import dataclass, field
from typing import Any


def _get_nested(data: dict, keys: list[str], default: Any = None) -> Any:
    """Navigate nested dict/list structure using key path."""
    try:
        for key in keys:
            try:
                data = data[key]
            except TypeError:
                # Handle list index access
                data = data[int(key)]
        return data
    except (KeyError, TypeError, ValueError, IndexError):
        return default


def _set_nested(data: dict, keys: list[str], value: Any) -> None:
    """Set a value in nested dict structure, creating intermediate dicts as needed."""
    for key in keys[:-1]:
        if key not in data:
            data[key] = {}
        data = data[key]
    data[keys[-1]] = value


@dataclass
class ExecutionContext:
    """
    Context object passed to nodes during workflow execution.

    Attributes:
        state: Mutable workflow state that persists across all nodes.
        config: Immutable configuration (global + workflow level).
        node_context: Data generated by nodes, keyed by node name.

    Field path format for get():
        - state.<path>: Get from state (e.g., "state.user.name")
        - config.<path>: Get from config (e.g., "config.timeout")
        - <node_name>.<path>: Get from node_context (e.g., "loop_node.item")
    """

    state: dict = field(default_factory=dict)
    config: dict = field(default_factory=dict)
    node_context: dict[str, dict] = field(default_factory=dict)

    def get(self, path: Any, default: Any = None) -> Any:
        """
        Extract a value using field path notation.

        Args:
            path: Field path in format "source.key1.key2..." or a literal value.
                  - "state.*" → get from state
                  - "config.*" → get from config
                  - "<node_name>.*" → get from node_context[node_name]
                  - "<key>" → fallback to state[key] for backward compatibility
                  - Non-string values are returned as-is (literal values)
            default: Value to return if path not found.

        Returns:
            The value at the path, or default if not found.
        """
        # Non-string values are treated as literals
        if not isinstance(path, str):
            return path

        if not path:
            return default

        parts = path.split(".")
        if len(parts) < 1:
            return default

        source = parts[0]
        remaining = parts[1:]

        if source == "state":
            if not remaining:
                return self.state
            return _get_nested(self.state, remaining, default)

        if source == "config":
            if not remaining:
                return self.config
            return _get_nested(self.config, remaining, default)

        # Check if it's a node name in node_context
        if source in self.node_context:
            node_data = self.node_context[source]
            if not remaining:
                return node_data
            return _get_nested(node_data, remaining, default)

        # Fallback: treat entire path as state lookup for backward compatibility
        result = _get_nested(self.state, parts, None)
        if result is not None:
            return result

        return default

    def set(self, path: str, value: Any) -> None:
        """
        Set a value in the state using field path notation.

        Args:
            path: Field path for state (e.g., "user.name" or "state.user.name")
            value: The value to set.

        Raises:
            ValueError: If trying to set config (immutable).
        """
        if not path:
            return

        parts = path.split(".")

        # Handle "state.x.y" format
        if parts[0] == "state":
            parts = parts[1:]

        if not parts:
            return

        # Check if trying to set config
        if parts[0] == "config":
            raise ValueError("Cannot modify config - it is immutable")

        _set_nested(self.state, parts, value)

    def set_node_context(self, node_name: str, data: dict) -> None:
        """
        Set the context data for a specific node.

        Args:
            node_name: The name of the node.
            data: The context data to store.
        """
        self.node_context[node_name] = data

    def update_node_context(self, node_name: str, key: str, value: Any) -> None:
        """
        Update a single key in a node's context.

        Args:
            node_name: The name of the node.
            key: The key to update.
            value: The value to set.
        """
        if node_name not in self.node_context:
            self.node_context[node_name] = {}
        self.node_context[node_name][key] = value

    def get_node_context(self, node_name: str) -> dict:
        """
        Get the context data for a specific node.

        Args:
            node_name: The name of the node.

        Returns:
            The node's context data, or empty dict if not found.
        """
        return self.node_context.get(node_name, {})

    def clear_node_context(self, node_name: str) -> None:
        """
        Remove a node's context data.

        Args:
            node_name: The name of the node.
        """
        self.node_context.pop(node_name, None)
